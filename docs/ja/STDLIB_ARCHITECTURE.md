# Restrict Language 標準ライブラリアーキテクチャ

## 概要

このドキュメントは、Restrict Languageの標準ライブラリのアーキテクチャと実装戦略を説明します。特にバックエンドWeb開発機能に焦点を当てています。

## コア設計方針

### 1. 実装戦略：ハイブリッドアプローチ

**ハードコードと.rl実装を組み合わせたハイブリッドアプローチ**を提案します：

#### ハードコード実装（コンパイラ内）：
- **コアプリミティブ**：メモリ割り当て、型変換、基本算術演算
- **ランタイム必須機能**：パニック処理、アサーション、コアI/O
- **パフォーマンスクリティカル**：直接WAT生成が有利な関数
- **ブートストラップ関数**：.rl標準ライブラリをロードするための最小セット

#### .rlライブラリファイル：
- **高レベルAPI**：HTTP、JSON、ファイル操作など
- **複雑なロジック**：パース、シリアライズ、プロトコル実装
- **ユーザー拡張可能**：コミュニティの貢献を可能に
- **バージョン管理**：コンパイラと独立して進化可能

### 2. バックエンド開発の優先順位

バックエンドWeb開発のための優先順位：

1. **基盤レイヤー** (P0)
   - WASIファイルI/O
   - プロセス環境（引数、環境変数、終了コード）
   - 基本ネットワーキング（WASI経由のTCPソケット）
   - 文字列操作ユーティリティ

2. **データレイヤー** (P1)
   - JSONパースとシリアライゼーション
   - URLパースとエンコーディング
   - Base64エンコーディング/デコーディング
   - 正規表現（基本的なもの）

3. **HTTPレイヤー** (P2)
   - HTTPサーバー（WASIソケット使用）
   - HTTPクライアント
   - Request/Response抽象化
   - ミドルウェアパターンサポート

4. **アプリケーションレイヤー** (P3)
   - ルーティングとパスマッチング
   - テンプレートレンダリング
   - セッション管理
   - データベースドライバー（ソケット経由のPostgreSQL）

5. **将来の検討事項** (P4)
   - async/awaitランタイム
   - ワーカースレッド
   - キャッシュ抽象化
   - メッセージキュー

### 3. ランタイムターゲット：WASI

WASI（WebAssembly System Interface）を主要ターゲットとして選択：

**利点：**
- システムコールの標準インターフェース
- 既存のランタイムサポート（Wasmtime、Wasmer、WasmEdge）
- 成長するエコシステム
- ケーパビリティベースモデルによるセキュリティ

**制限事項：**
- 組み込みの非同期I/Oがない（まだ）
- 初期はWASI preview 1の機能に限定
- 一部の機能はランタイム拡張が必要

### 4. 実装ロードマップ

#### フェーズ1：基盤（1-2週目）
- [ ] より簡単なFFIのためのWASMインポートシステムの拡張
- [ ] コンパイラに基本的なWASIラッパーを実装
- [ ] std/ディレクトリ構造を作成
- [ ] コア文字列ユーティリティを.rlで実装

#### フェーズ2：データフォーマット（3-4週目）
- [ ] .rlでJSONパーサーを実装
- [ ] JSONシリアライゼーションを追加
- [ ] エラーハンドリング用のResult<T, E>型を作成
- [ ] URLパーシングを追加

#### フェーズ3：I/O＆ネットワーキング（5-6週目）
- [ ] WASIファイル操作をラップ
- [ ] TCPソケットラッパーを実装
- [ ] バッファードI/Oを追加
- [ ] ストリーム抽象化を作成

#### フェーズ4：HTTP実装（7-8週目）
- [ ] HTTPリクエスト/レスポンスパーシング
- [ ] 基本的なHTTPサーバー
- [ ] ルーティングシステム
- [ ] ミドルウェアサポート

## 次のステップ

1. このアーキテクチャをレビューして洗練する
2. .rlでJSONパーサーの概念実証を作成
3. 基本的なWASIファイルI/Oラッパーを実装
4. シンプルなHTTPサーバープロトタイプを構築
5. コミュニティからフィードバックを収集

## 未解決の質問

1. async/await構文をサポートすべきか、それともコールバック/Promiseを使うべきか？
2. プラットフォーム固有の機能（例：Unixソケット）をどう扱うか？
3. 標準ライブラリは単一パッケージか複数パッケージか？
4. 標準ライブラリをコンパイラと独立してバージョン管理する方法は？
5. コンパイル時コード生成（deriveマクロ）の最適なアプローチは？