<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Type System - The Restrict Language Programming Guide</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../../theme/restrict-lang.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../../";
            const default_light_theme = "light";
            const default_dark_theme = "coal";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>‚Üê</kbd> or <kbd>‚Üí</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Restrict Language Programming Guide</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/restrict-lang/restrict_lang" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/restrict-lang/restrict_lang/edit/main/docs/./en/guide/types.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="type-system"><a class="header" href="#type-system">Type System</a></h1>
<p>Restrict Language features a sophisticated type system that combines static typing, affine types for memory safety, and powerful type inference. This guide explores the type system in detail.</p>
<h2 id="affine-types"><a class="header" href="#affine-types">Affine Types</a></h2>
<p>The most distinctive feature of Restrict Language is its affine type system. An affine type ensures that values can be used <strong>at most once</strong>.</p>
<h3 id="what-are-affine-types"><a class="header" href="#what-are-affine-types">What are Affine Types?</a></h3>
<pre><code class="language-restrict">let message = "Hello";
message |&gt; println;     // Ownership transferred to println
// message |&gt; println;  // ERROR: message already consumed
</code></pre>
<p>This prevents common bugs like:</p>
<ul>
<li>Use-after-free</li>
<li>Double-free</li>
<li>Data races</li>
</ul>
<h3 id="when-types-are-consumed"><a class="header" href="#when-types-are-consumed">When Types are Consumed</a></h3>
<p>A value is consumed when:</p>
<ol>
<li><strong>Passed to a function</strong></li>
</ol>
<pre><code class="language-restrict">let data = getData()
data |&gt; process  // data consumed
// data is no longer available
</code></pre>
<ol start="2">
<li><strong>Assigned to another variable</strong></li>
</ol>
<pre><code class="language-restrict">let x = createResource()
let y = x  // x consumed
// x is no longer available
</code></pre>
<ol start="3">
<li><strong>Returned from a function</strong></li>
</ol>
<pre><code class="language-restrict">fn transfer(resource: Resource) -&gt; Resource {
    resource  // Ownership transferred to caller
}
</code></pre>
<h3 id="working-with-affine-types"><a class="header" href="#working-with-affine-types">Working with Affine Types</a></h3>
<h4 id="cloning"><a class="header" href="#cloning">Cloning</a></h4>
<p>When you need to use a value multiple times, use <code>clone</code>:</p>
<pre><code class="language-restrict">let original = "Hello"
let copy = clone original

original |&gt; println  // OK
copy |&gt; println      // OK
</code></pre>
<h4 id="pattern-matching"><a class="header" href="#pattern-matching">Pattern Matching</a></h4>
<p>Pattern matching with affine types:</p>
<pre><code class="language-restrict">let result = compute();
match result {
    Ok(value) =&gt; value |&gt; process,  // value consumed in this branch
    Err(error) =&gt; error |&gt; logError  // error consumed in this branch
}
// result is fully consumed
</code></pre>
<h2 id="primitive-types"><a class="header" href="#primitive-types">Primitive Types</a></h2>
<h3 id="numeric-types"><a class="header" href="#numeric-types">Numeric Types</a></h3>
<pre><code class="language-restrict">// Signed integers
let i8_val: i8 = -128
let i16_val: i16 = -32768
let i32_val: i32 = -2147483648
let i64_val: i64 = -9223372036854775808
let i128_val: i128 = -170141183460469231731687303715884105728

// Unsigned integers
let u8_val: u8 = 255
let u16_val: u16 = 65535
let u32_val: u32 = 4294967295
let u64_val: u64 = 18446744073709551615
let u128_val: u128 = 340282366920938463463374607431768211455

// Floating point
let f32_val: f32 = 3.14159
let f64_val: f64 = 2.718281828459045

// Platform-specific
let size: usize = 100  // Pointer-sized unsigned
let diff: isize = -50  // Pointer-sized signed
</code></pre>
<h3 id="boolean-type"><a class="header" href="#boolean-type">Boolean Type</a></h3>
<pre><code class="language-restrict">let is_ready: bool = true
let is_finished: bool = false

// Boolean operations
let both = is_ready &amp;&amp; is_finished
let either = is_ready || is_finished
let not_ready = !is_ready
</code></pre>
<h3 id="character-type"><a class="header" href="#character-type">Character Type</a></h3>
<pre><code class="language-restrict">let letter: char = 'A'
let emoji: char = 'üòÄ'
let unicode: char = '\u{1F600}'
</code></pre>
<h3 id="unit-type"><a class="header" href="#unit-type">Unit Type</a></h3>
<p>The unit type <code>()</code> represents an empty value:</p>
<pre><code class="language-restrict">fn do_nothing() -&gt; () {
    // Returns unit
}

let unit_value: () = ()
</code></pre>
<h2 id="string-types"><a class="header" href="#string-types">String Types</a></h2>
<h3 id="string-owned"><a class="header" href="#string-owned">String (Owned)</a></h3>
<p><code>String</code> is an affine type representing owned UTF-8 text:</p>
<pre><code class="language-restrict">let mut greeting: String = "Hello"
greeting = greeting ++ ", World!"  // Concatenation

// String is consumed when used
greeting |&gt; println
// greeting no longer available
</code></pre>
<h3 id="str-string-slice"><a class="header" href="#str-string-slice">&amp;str (String Slice)</a></h3>
<p>String slices are borrowed views into strings:</p>
<pre><code class="language-restrict">let full_name = "John Doe"
let first_name: &amp;str = &amp;full_name[0..4]  // "John"
</code></pre>
<h2 id="compound-types"><a class="header" href="#compound-types">Compound Types</a></h2>
<h3 id="arrays"><a class="header" href="#arrays">Arrays</a></h3>
<p>Fixed-size sequences of elements:</p>
<pre><code class="language-restrict">let numbers: [i32; 5] = [1, 2, 3, 4, 5]
let zeros: [i32; 100] = [0; 100]  // 100 zeros

// Array access
let first = numbers[0]
let last = numbers[4]
</code></pre>
<h3 id="slices"><a class="header" href="#slices">Slices</a></h3>
<p>Dynamic views into arrays:</p>
<pre><code class="language-restrict">let array = [1, 2, 3, 4, 5]
let slice: &amp;[i32] = &amp;array[1..4]  // [2, 3, 4]

// Slice operations
slice |&gt; len      // 3
slice[0]          // 2
</code></pre>
<h3 id="tuples"><a class="header" href="#tuples">Tuples</a></h3>
<p>Fixed-size heterogeneous collections:</p>
<pre><code class="language-restrict">let person: (String, i32, bool) = ("Alice", 30, true)
let (name, age, active) = person  // Destructuring

// Accessing tuple elements
let coordinates: (f64, f64) = (10.5, 20.7)
let x = coordinates.0
let y = coordinates.1
</code></pre>
<h3 id="vectors"><a class="header" href="#vectors">Vectors</a></h3>
<p>Dynamic arrays (affine type):</p>
<pre><code class="language-restrict">let mut vec: Vec&lt;i32&gt; = Vec::new()
vec |&gt;&gt; push(1)
vec |&gt;&gt; push(2)
vec |&gt;&gt; push(3)

// Vector is consumed when iterated
vec |&gt; iter |&gt; map(|x| x * 2) |&gt; collect
</code></pre>
<h2 id="custom-types"><a class="header" href="#custom-types">Custom Types</a></h2>
<h3 id="structs"><a class="header" href="#structs">Structs</a></h3>
<p>Named collections of fields:</p>
<pre><code class="language-restrict">struct User {
    name: String,
    email: String,
    age: u32,
    active: bool
}

// Creating instances
let user = User {
    name: "Alice",
    email: "alice@example.com",
    age: 30,
    active: true
}

// Field access
let name = clone user.name  // Clone to avoid consuming user
</code></pre>
<h3 id="tuple-structs"><a class="header" href="#tuple-structs">Tuple Structs</a></h3>
<p>Structs with unnamed fields:</p>
<pre><code class="language-restrict">struct Point(f64, f64)
struct Color(u8, u8, u8)

let origin = Point(0.0, 0.0)
let red = Color(255, 0, 0)

// Accessing fields
let x = origin.0
let r = red.0
</code></pre>
<h3 id="enums"><a class="header" href="#enums">Enums</a></h3>
<p>Sum types with variants:</p>
<pre><code class="language-restrict">enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E)
}

enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(u8, u8, u8)
}

// Pattern matching
let msg = Message::Move { x: 10, y: 20 }
match msg {
    Message::Quit =&gt; quit(),
    Message::Move { x, y } =&gt; moveTo(x, y),
    Message::Write(text) =&gt; text |&gt; display,
    Message::ChangeColor(r, g, b) =&gt; setColor(r, g, b)
}
</code></pre>
<h2 id="type-aliases"><a class="header" href="#type-aliases">Type Aliases</a></h2>
<p>Create alternative names for types:</p>
<pre><code class="language-restrict">type UserId = u64
type Result&lt;T&gt; = Result&lt;T, String&gt;
type Callback = fn(Event) -&gt; bool

let id: UserId = 12345
let result: Result&lt;i32&gt; = Ok(42)
</code></pre>
<h2 id="option-and-result"><a class="header" href="#option-and-result">Option and Result</a></h2>
<h3 id="option-type"><a class="header" href="#option-type">Option Type</a></h3>
<p>Represents optional values:</p>
<pre><code class="language-restrict">enum Option&lt;T&gt; {
    Some(T),
    None
}

// Using Option
let maybe_number: Option&lt;i32&gt; = Some(42)
let nothing: Option&lt;i32&gt; = None

// Pattern matching
match maybe_number {
    Some(n) =&gt; n |&gt; process,
    None =&gt; handleMissing()
}

// Option methods
maybe_number |&gt; map(|n| n * 2)
maybe_number |&gt; unwrap_or(0)
</code></pre>
<h3 id="result-type"><a class="header" href="#result-type">Result Type</a></h3>
<p>Represents success or failure:</p>
<pre><code class="language-restrict">enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E)
}

// Using Result
let result: Result&lt;i32, String&gt; = Ok(42)
let error: Result&lt;i32, String&gt; = Err("Failed")

// Error handling
result
    |&gt; map(|n| n * 2)
    |&gt; map_err(|e| "Error: " ++ e)
    |&gt; unwrap_or_else(|_| 0)
</code></pre>
<h2 id="generic-types"><a class="header" href="#generic-types">Generic Types</a></h2>
<h3 id="generic-functions"><a class="header" href="#generic-functions">Generic Functions</a></h3>
<pre><code class="language-restrict">fn identity&lt;T&gt;(value: T) -&gt; T {
    value
}

fn swap&lt;A, B&gt;(pair: (A, B)) -&gt; (B, A) {
    let (a, b) = pair
    (b, a)
}
</code></pre>
<h3 id="generic-structs"><a class="header" href="#generic-structs">Generic Structs</a></h3>
<pre><code class="language-restrict">struct Container&lt;T&gt; {
    value: T
}

impl&lt;T&gt; Container&lt;T&gt; {
    fn new(value: T) -&gt; Container&lt;T&gt; {
        Container { value }
    }
    
    fn get(self) -&gt; T {
        self.value  // Consumes container
    }
}
</code></pre>
<h3 id="type-constraints"><a class="header" href="#type-constraints">Type Constraints</a></h3>
<pre><code class="language-restrict">fn display&lt;T: ToString&gt;(value: T) {
    value |&gt; toString |&gt; println
}

fn process&lt;T&gt;(items: Vec&lt;T&gt;) -&gt; Vec&lt;String&gt;
    where T: ToString + Clone
{
    items |&gt; map(|item| item |&gt; toString) |&gt; collect
}
</code></pre>
<h2 id="type-inference"><a class="header" href="#type-inference">Type Inference</a></h2>
<p>Restrict Language has powerful type inference:</p>
<pre><code class="language-restrict">// Compiler infers types
let x = 42           // i32
let y = 3.14         // f64
let z = "hello"      // &amp;str
let vec = vec![1, 2, 3]  // Vec&lt;i32&gt;

// Partial type annotations
let numbers: Vec&lt;_&gt; = vec![1, 2, 3]
let result = parse::&lt;i32&gt;("42")
</code></pre>
<h2 id="prototype-based-types"><a class="header" href="#prototype-based-types">Prototype-Based Types</a></h2>
<p>Restrict Language supports prototype-based inheritance:</p>
<pre><code class="language-restrict">// Create a prototype
let animal_proto = freeze {
    species: "unknown",
    makeSound: fn() { "..." |&gt; println }
}

// Derive from prototype
let dog = clone animal_proto with {
    species: "dog",
    makeSound: fn() { "Woof!" |&gt; println }
}

// Type with derivation bound
fn feed&lt;T from animal_proto&gt;(animal: T) {
    animal.species |&gt; println
    animal.makeSound()
}
</code></pre>
<h2 id="memory-safety"><a class="header" href="#memory-safety">Memory Safety</a></h2>
<p>The affine type system ensures memory safety without garbage collection:</p>
<pre><code class="language-restrict">// Resource management
with file = openFile("data.txt") {
    file |&gt; read |&gt; process
}  // file automatically closed

// No double-free
let resource = allocate()
resource |&gt; use
// resource |&gt; use  // ERROR: already consumed

// No use-after-free
let data = getData()
let processed = data |&gt; transform  // data consumed
// data |&gt; print  // ERROR: data no longer available
</code></pre>
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<ol>
<li><strong>Embrace affine types</strong> - They prevent bugs at compile time</li>
<li><strong>Use clone sparingly</strong> - Only when you truly need multiple uses</li>
<li><strong>Leverage type inference</strong> - But add annotations for clarity</li>
<li><strong>Pattern match exhaustively</strong> - The compiler ensures all cases are handled</li>
<li><strong>Use Option and Result</strong> - For explicit error handling</li>
</ol>
<h2 id="advanced-topics"><a class="header" href="#advanced-topics">Advanced Topics</a></h2>
<h3 id="phantom-types"><a class="header" href="#phantom-types">Phantom Types</a></h3>
<pre><code class="language-restrict">struct Distance&lt;Unit&gt; {
    value: f64,
    _unit: PhantomData&lt;Unit&gt;
}

struct Meters
struct Feet

let d1: Distance&lt;Meters&gt; = Distance::new(100.0)
let d2: Distance&lt;Feet&gt; = Distance::new(328.0)
// Can't accidentally mix units
</code></pre>
<h3 id="associated-types"><a class="header" href="#associated-types">Associated Types</a></h3>
<pre><code class="language-restrict">trait Container {
    type Item
    fn get(self) -&gt; Self::Item
}

impl Container for Box&lt;T&gt; {
    type Item = T
    fn get(self) -&gt; T {
        self.value
    }
}
</code></pre>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>Restrict Language‚Äôs type system provides:</p>
<ul>
<li><strong>Memory safety</strong> through affine types</li>
<li><strong>Expressiveness</strong> through generics and type inference</li>
<li><strong>Performance</strong> with zero-cost abstractions</li>
<li><strong>Correctness</strong> through exhaustive pattern matching</li>
</ul>
<p>The combination of affine types and OSV syntax creates a unique programming experience that catches bugs at compile time while remaining ergonomic and expressive.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../en/guide/syntax.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../en/guide/ownership.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../en/guide/syntax.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../en/guide/ownership.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>


        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="../../ace.js"></script>
        <script src="../../mode-rust.js"></script>
        <script src="../../editor.js"></script>
        <script src="../../theme-dawn.js"></script>
        <script src="../../theme-tomorrow_night.js"></script>

        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../../theme/restrict-lang.js"></script>


    </div>
    </body>
</html>
