# 固定長配列型仕様

## 概要
Restrict Languageにおける固定長配列は、コンパイル時に長さが決まる配列型です。
リストとは異なり、サイズは変更できませんが、より効率的なメモリレイアウトを持ちます。

## 構文

### 配列型宣言
```
Array[Int, 10]     // 10要素のInt配列
Array[String, 5]   // 5要素のString配列
```

### 配列リテラル
```
[|1, 2, 3, 4, 5|]  // 5要素の配列
```

注: 通常のリスト `[1, 2, 3]` とは異なる構文を使用

## メモリレイアウト

固定長配列はヘッダーなしで、要素が直接連続して配置されます：

```
+-------+-------+-------+-----+
| elem0 | elem1 | elem2 | ... |
+-------+-------+-------+-----+
```

リストのようなlength/capacityヘッダーは不要です。

## 型システム

- `Array[T, N]` は `List[T]` とは異なる型
- 配列の長さは型の一部
- `Array[Int, 5]` と `Array[Int, 10]` は異なる型

## 操作

### インデックスアクセス
```
val arr = [|10, 20, 30, 40, 50|];
val second = arr array_get 1;  // 20
```

### 長さ取得
配列の長さは型情報から静的に決まるため、実行時の長さ取得は不要ですが、
便宜上提供されます：

```
val len = arr array_length;  // 5
```

### 更新（mutable配列の場合）
```
mut val arr = [|10, 20, 30, 40, 50|];
arr array_set 2 35;  // arr[2] = 35
```

## 実装上の利点

1. ヘッダーが不要なため、メモリ効率が良い
2. 長さが静的に決まるため、境界チェックを最適化できる
3. スタック割り当てが可能（小さい配列の場合）

## 制限事項

1. サイズは変更不可
2. push/pop操作は不可
3. 異なる長さの配列間での直接代入は不可