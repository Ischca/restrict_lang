# Temporal Type Variables: Final Design

## Core Concept

**Temporal Type Variables** are type parameters that represent when a resource is valid, using the `~` prefix.

```restrict
record File<~f> {
    handle: FileHandle
}

record Connection<~conn> {
    socket: Socket
}
```

## Syntax Summary

### 1. **Temporal Type Variables with `~`**
```restrict
// Declaration
record Cache<T, ~valid> {
    data: T
    timestamp: Time<~valid>
}

// Function signature
fun process<~io> = file: File<~io> -> Result<~io>

// Constraints
fun transfer<~tx, ~db> = tx: Transaction<~tx, ~db> -> Unit
where ~tx within ~db
```

### 2. **Context Integration**
```restrict
// Contexts implicitly create temporal variables
with Database {                    // Creates ~db
    Database.connect { conn ->     // conn: Connection<~db>
        conn.beginTx { tx ->       // tx: Transaction<~tx>
            // ~tx within ~db automatically enforced
        }
    }
}
```

### 3. **Naming Conventions**
```restrict
// Type variables: uppercase
T, U, V, K, V

// Temporal variables: lowercase with ~
~t, ~u, ~v           // Generic
~conn, ~tx, ~req     // Descriptive
~io, ~net, ~mem      // Domain-specific
```

## Complete Examples

### File I/O
```restrict
record File<~f> {
    handle: FileHandle
    path: String
}

context FileSystem<~fs> {
    open: (String, File<~fs> -> R) -> R
}

fun copyFile = source: String dest: String {
    with FileSystem {
        FileSystem.open(source) { input ->     // input: File<~fs>
            FileSystem.open(dest) { output ->  // output: File<~fs>
                input.read() |> output.write
            }
        }
    }  // Both files automatically closed
}
```

### Database Transactions
```restrict
record Database<~db> {
    connection: Connection
}

record Transaction<~tx, ~db> where ~tx within ~db {
    db: Database<~db>
    id: TransactionId
}

fun transferMoney = amount: Money {
    with DatabaseContext {
        DatabaseContext.connect { db ->          // db: Database<~ctx>
            db.beginTransaction { tx ->          // tx: Transaction<~tx, ~ctx>
                tx.debit(accountA, amount);
                tx.credit(accountB, amount);
                tx.commit();
            }  // Auto-rollback if not committed
        }
    }
}
```

### HTTP Server
```restrict
record Server<~server> {
    port: Int
    handler: Handler<~server>
}

record Request<~req, ~server> where ~req within ~server {
    headers: Map<String, String>
    body: Stream<~req>
}

fun startServer = port: Int {
    with ServerContext {
        ServerContext.listen(port) { server ->   // server: Server<~ctx>
            server.onRequest { request ->        // request: Request<~req, ~ctx>
                val response = handleRequest(request);
                response.send();
            }  // Request automatically cleaned up
        }
    }
}
```

## OSV Integration

Temporal types work naturally with OSV syntax:

```restrict
fun processData<~io> = filename: String {
    with FileSystem {
        (filename) FileSystem.open { file ->    // file: File<~io>
            (file) read
            |> parse
            |> validate
            |> transform
            |> (file) write
        }
    }
}
```

## Type System Integration

### 1. **Temporal Variables are Type Variables**
```restrict
// Both are just type parameters
record Pair<T, U> { first: T, second: U }
record Lease<T, ~valid> { resource: T, expiry: Time<~valid> }
```

### 2. **Inference Works the Same**
```restrict
// Type inference
val list = [1, 2, 3];            // List<Int> inferred

// Temporal inference
val file = fs.open("data.txt");  // File<~1> inferred
```

### 3. **Constraints are Uniform**
```restrict
// Type constraints
fun sort<T: Ord> = list: List<T> -> List<T>

// Temporal constraints
fun nested<~a, ~b> = outer: Resource<~a> inner: Resource<~b> -> Unit
where ~b within ~a
```

## Error Messages

```
Error: Temporal variable ~tx must be within ~db
Error: Cannot return value with temporal ~conn outside its scope
Error: Resource with temporal ~io has expired
Error: Temporal ~a does not outlive ~b
```

## Implementation Roadmap

### Phase 1: Parser Support
- Add `~` prefix for temporal variables
- Extend type parameter syntax
- Parse `where` constraints

### Phase 2: Type System
- Add temporal variables to type checker
- Implement lifetime inference
- Validate temporal constraints

### Phase 3: Code Generation
- Insert cleanup code at scope boundaries
- Handle early returns and exceptions
- Optimize redundant cleanups

### Phase 4: Standard Library
- Convert I/O to temporal types
- Add temporal contexts
- Migration guide for existing code

## Benefits

1. **Zero-cost** - All checks at compile time
2. **Automatic** - Cleanup code generated by compiler
3. **Safe** - Impossible to leak or use-after-free
4. **Composable** - Functions can accept/return temporal types
5. **Familiar** - Just like regular type variables

## Summary

Temporal type variables with `~` provide:
- Clear visual distinction
- Natural integration with existing type system
- Automatic resource management
- Type-safe temporal constraints

This design makes Restrict Language uniquely powerful for systems programming while maintaining its clean, intuitive syntax.